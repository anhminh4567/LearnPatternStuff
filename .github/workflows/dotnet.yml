# This workflow will build a .NET project
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-net

name: .NET

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      branch_name: 
        required: true
        description: 'provide the branch name to begin'
        type: text 
      environment_to_deploy:
        required: true
        description: 'provide the environement to deploy, dev or production or test'
        type: choice 
        options:
          - 'Development'
          - 'Staging'
          - 'Productionp'
jobs:
  validation:
    runs-on: self-hosted
    env:
      REMOTE_NAME: origin
    outputs:
      IS_BRANCH_EXISTS: ${{ steps.OUTPUT_RESULT.outputs.IS_BRANCH_EXISTS }}
    steps:
      - name: check if branch user input exist
        run : |
          echo "check if the user input for branch is correct, the user input is ${{ inputs.branch_name }} "
          $RemoteBranchQueryResult = git ls-remote ${{ env.REMOTE_NAME }} refs/heads/${{ inputs.branch_name }} 
          $IsBranchExist = $false
          if($RemoteBranchQueryResult -contains "refs/heads/${{ inputs.branch_name}}" ){
            $IsBranchExist = $true
            echo "branch exists: "$IsBranchExist
          }else{
            $IsBranchExist = $false
            echo "branch exists: "$IsBranchExist
          }
      - name: Output result
        run: | 
          if($IsBranchExist){
            $IS_BRANCH_EXISTS = $IsBranchExist 
            $IS_BRANCH_EXISTS | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }else{
            exit 1
          }
  build:
    runs-on: self-hosted
    needs: [validation]
    if: ${{ needs.validation.outputs.IS_BRANCH_EXISTS }}
    env:
      ARTIFACT_NAME: 'learnPatternStuffArtifact'
    outputs:
      artifact_name_final: ${{ steps.outputing_final.outputs.artifact_name_final }}
    steps:
    - uses: actions/checkout@v4
    - name: Print dotnet version and check if build directory exist to create
      run : |
        dotnet --version
        $publishPath = Join-Path $env:GITHUB_WORKSPACE "publishPath"
        echo "check if this path exist: $publishPath"
        if (Test-Path $publishPath){
          echo "publishPath exist no need to create"
        }else{
          echo "create new path"
          mkdir $publishPath
        }
        "PUBLISH_OUTPUT_DIRECTORY=$publishPath" | Out-File -FilePath $env:GITHUB_ENV -Append
    - name: print some variable
      run: |
        echo "github workspace: $env:GITHUB_WORKSPACE"
        echo "output of build directory: $env:PUBLISH_OUTPUT_DIRECTORY"
        echo "finish printing"
         
    - name: Restore dependencies
      run: dotnet restore
    - name: Build
      run: dotnet build --no-restore
    - name: Publish
      run: dotnet publish --no-build --output $env:PUBLISH_OUTPUT_DIRECTORY
    - name: upload artifact, in this case, a zip or rar file
      uses: actions/upload-artifact@v4.3.1
      with:
        name: ${{ env.ARTIFACT_NAME }}-${{ github.run_number }}
        path: ${{ env.PUBLISH_OUTPUT_DIRECTORY }}
        overwrite: true
    - name: Outputing any possible value
      id: outputing_final        
      run: |
        echo "artifact_name is ${{ env.ARTIFACT_NAME }}-${{ github.run_number }}"
        echo "artifact_name_final=${{ env.ARTIFACT_NAME }}-${{ github.run_number }}" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
        
      
  deploy:
    needs: [build]
    runs-on: self-hosted
    env:
      DEPLOYMENT_PATH: 'E:\DEPLOYMENT\GITHUB'
    steps:
    - name: validate if directory can be accessed and create a dummy file
      run : |
        if(Test-Path $env:DEPLOYMENT_PATH){
          echo "path exist, no need to create"
        }else{
          mkdir $env:DEPLOYMENT_PATH
          echo "created"
        }
        cd "E:\DEPLOYMENT\GITHUB"
        pwd
    - name: end 
      run: | 
        echo "finish"
        echo "value for artifact name is: ${{ needs.build.outputs.artifact_name_final }}"
    # - name: Docker Login
    #   uses: docker/login-action@v3.1.0
    #   with:
    #     username:
    #     password:
        
        

    
